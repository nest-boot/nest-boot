---
title: "MikroORM"
description: "MikroORM integration with request-scoped entity manager, EntityService base class, encrypted/hashed properties, and request transactions."
---

The `@nest-boot/mikro-orm` module wraps [`@mikro-orm/nestjs`](https://mikro-orm.io/docs/usage-with-nestjs) with automatic environment-based configuration and request context integration for per-request entity manager forking. Companion modules provide [encrypted properties](#encrypted-properties), [hashed properties](#hashed-properties), and [request-scoped transactions](#request-transactions).

## Installation

```bash
pnpm add @nest-boot/mikro-orm @mikro-orm/core @mikro-orm/postgresql @mikro-orm/migrations
```

## Module Registration

### Basic Registration

```typescript
import { MikroOrmModule } from "@nest-boot/mikro-orm";

@Global()
@Module({
  imports: [MikroOrmModule],
})
export class CommonModule {}
```

When no options are passed, the module auto-loads configuration from environment variables using `loadConfigFromEnv()`, which reads:

- `DATABASE_URL` — PostgreSQL connection string
- Entity discovery via `tsconfig.json` paths

### Async Registration

```typescript
import { MikroOrmModule } from "@nest-boot/mikro-orm";
import { ConfigService } from "@nestjs/config";

@Module({
  imports: [
    MikroOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        clientUrl: configService.getOrThrow("DATABASE_URL"),
      }),
    }),
  ],
})
export class CommonModule {}
```

### CLI Configuration

For MikroORM CLI (migrations, schema generation), create a `mikro-orm.config.ts`:

```typescript
import "dotenv/config";
import { loadConfigFromEnv } from "@nest-boot/mikro-orm";

export default loadConfigFromEnv();
```

## Request-Scoped Entity Manager

The module automatically forks the entity manager for each request via `RequestContext`, ensuring proper isolation. You can inject `EntityManager` anywhere:

```typescript
import { EntityManager } from "@mikro-orm/postgresql";
import { Injectable } from "@nestjs/common";

@Injectable()
export class UserService {
  constructor(private readonly em: EntityManager) {}

  async findAll() {
    return this.em.findAll(User);
  }
}
```

## EntityService

`EntityService` is a generic CRUD base class with DataLoader batching for automatic N+1 prevention:

```typescript
import { EntityManager, FilterQuery } from "@mikro-orm/postgresql";
import { EntityService } from "@nest-boot/mikro-orm";
import { Injectable } from "@nestjs/common";

import { User } from "./user.entity";

@Injectable()
export class UserService extends EntityService<User> {
  constructor(protected readonly em: EntityManager) {
    super(User, em);
  }
}
```

### Available Methods

| Method                                | Description                                                            |
| ------------------------------------- | ---------------------------------------------------------------------- |
| `create(data)`                        | Create and persist a new entity                                        |
| `findOne(idOrEntity)`                 | Find by ID, entity reference, or filter query (batched via DataLoader) |
| `findOneOrFail(idOrEntity)`           | Same as `findOne` but throws `NotFoundException`                       |
| `findAll(where, options?)`            | Find all entities matching a filter                                    |
| `count(where, options?)`              | Count matching entities                                                |
| `update(idOrEntity, data)`            | Update an entity                                                       |
| `remove(idOrEntity, softDelete?)`     | Remove an entity (supports soft-delete)                                |
| `chunkById(where, options, callback)` | Iterate entities in chunks for batch processing                        |

### Soft Delete

`EntityService` supports soft delete when configured with a `softDeleteKey`:

```typescript
@Injectable()
export class FileService extends EntityService<File> {
  constructor(protected readonly em: EntityManager) {
    super(File, em, { softDeleteKey: "deletedAt" });
  }
}

// Soft delete (sets deletedAt = new Date())
await this.fileService.remove(fileId);

// Hard delete
await this.fileService.remove(fileId, false);
```

### Chunk Processing

Process large datasets in batches:

```typescript
await this.userService.chunkById(
  { isActive: true },
  { limit: 100 },
  async (users) => {
    for (const user of users) {
      await this.sendEmail(user);
    }
  },
);
```

## Encrypted Properties

The `@nest-boot/mikro-orm-crypt` module provides the `@EncryptedProperty()` decorator for transparent field encryption using the `@nest-boot/crypt` module:

```bash
pnpm add @nest-boot/mikro-orm-crypt @nest-boot/crypt
```

```typescript
import { Entity, PrimaryKey, t } from "@mikro-orm/postgresql";
import { EncryptedProperty } from "@nest-boot/mikro-orm-crypt";

@Entity()
export class CloudProviderAccount {
  @PrimaryKey({ type: t.bigint })
  id!: string;

  @EncryptedProperty()
  apiKey!: string;

  @EncryptedProperty()
  apiSecret!: string;
}
```

Values are automatically encrypted on write and decrypted on read. Requires `CryptModule` to be registered:

```typescript
import { CryptModule } from "@nest-boot/crypt";

const CryptDynamicModule = CryptModule.registerAsync({
  inject: [ConfigService],
  useFactory: (configService: ConfigService) => ({
    secret: configService.get("APP_SECRET", "secret"),
  }),
});
```

## Hashed Properties

The `@nest-boot/mikro-orm-hash` module provides the `@HashedProperty()` decorator for transparent field hashing using the `@nest-boot/hash` module:

```bash
pnpm add @nest-boot/mikro-orm-hash @nest-boot/hash
```

```typescript
import { Entity, PrimaryKey, t } from "@mikro-orm/postgresql";
import { HashedProperty } from "@nest-boot/mikro-orm-hash";

@Entity()
export class User {
  @PrimaryKey({ type: t.bigint })
  id!: string;

  @HashedProperty()
  password!: string;
}
```

Values are automatically hashed on write. Requires `HashModule` to be registered.

## Request Transactions

The `@nest-boot/mikro-orm-request-transaction` module wraps each request in a database transaction, which is essential for RLS and data consistency:

```bash
pnpm add @nest-boot/mikro-orm-request-transaction
```

```typescript
import { RequestTransactionModule } from "@nest-boot/mikro-orm-request-transaction";

@Module({
  imports: [RequestTransactionModule],
})
export class CommonModule {}
```

The transaction is automatically committed on success and rolled back on error.

## Best Practices

1. **Environment Config** — Use `loadConfigFromEnv()` for both runtime and CLI configuration to keep them in sync.

2. **EntityService as Base** — Extend `EntityService` for all domain services to get CRUD + DataLoader batching out of the box.

3. **Request Transactions** — Always use `RequestTransactionModule` when using Auth-RLS for proper transaction scoping.

4. **Soft Delete** — Configure `softDeleteKey` in `EntityService` for entities that support soft delete.

## API Reference

For detailed API documentation, see the [MikroORM API Reference](/docs/api/mikro-orm), [MikroORM Crypt API Reference](/docs/api/mikro-orm-crypt), [MikroORM Hash API Reference](/docs/api/mikro-orm-hash), and [Request Transaction API Reference](/docs/api/mikro-orm-request-transaction).
